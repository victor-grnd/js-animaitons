// ============================================
// ⭐ ANIMATION DES BORDURES DE BOUTON ⭐
// Cette fonction gère les variables CSS --x et --r2
// ============================================

function initBtnWrapAnimation() {
  function lerp(start, end, progress) {
    return start + (end - start) * progress;
  }
  function animateRotation(element, duration, startTime) {
    const now = Date.now();
    let rotation;
    let progress = (now - startTime) / duration;

    if (progress < 0.3282275711) {
      rotation = lerp(0, 0, progress / 0.3282275711); // mettre le progress par rapport aux 33% premiers pourcents
    } else if (progress < 0.5) {
      rotation = lerp(0, 180, (progress - 0.3282275711) / 0.1717724289); // normaliser progress pour avoir 0-1 entre 33% et 50% 0.17 = diff entre ,5 et ,33
    } else if (progress < 0.8282275711) {
      rotation = 180; // il reste a 80 de 0.5 à 0.82
    } else if (progress <= 1) {
      rotation = lerp(180, 360, (progress - 0.8282275711) / 0.1717724289); // normaliser sur la diff entre 1 et 0.82
    } else {
      rotation = 360;
      startTime = now; // by setting startTime to now progress is reset to 0
    }

    element.style.setProperty("--r2", `${rotation}deg`);

    const animationFrameId = requestAnimationFrame(() =>
      animateRotation(element, duration, startTime)
    );

    // Stocker l'ID de l'animation frame
    animationStates.set(element, {
      ...animationStates.get(element),
      r2: animationFrameId,
    });
  }

  // Animation de position horizontale (--x)
  function animatePosition(element, duration, startTime) {
    const now = Date.now();
    let position;
    let progress = (now - startTime) / duration;

    // Animation par segments avec des paliers
    if (progress < 0.3282275711) {
      position = lerp(10, 90, progress / 0.3282275711);
    } else if (progress < 0.5) {
      position = 90;
    } else if (progress < 0.8282275711) {
      position = lerp(90, 10, (progress - 0.5) / 0.3282275711);
    } else if (progress <= 1) {
      position = 10;
    } else {
      position = 10;
      startTime = now; // Recommencer l'animation
    }

    element.style.setProperty("--x", `${position}%`);

    const animationFrameId = requestAnimationFrame(() =>
      animatePosition(element, duration, startTime)
    );

    // Stocker l'ID de l'animation frame
    animationStates.set(element, {
      ...animationStates.get(element),
      x: animationFrameId,
    });
  }

  const buttons = document.querySelectorAll(".btn_border");

  if (!buttons.length) return;

  const animationStates = new Map();

  // Initialiser les animations pour chaque bouton
  buttons.forEach((button) => {
    const existingState = animationStates.get(button);

    // Annuler les animations précédentes si elles existent
    if (existingState) {
      cancelAnimationFrame(existingState.r2);
      cancelAnimationFrame(existingState.x);
    }

    // Démarrer les animations (durée: 6 secondes)
    animateRotation(button, 6000, Date.now());
    animatePosition(button, 6000, Date.now());
  });
}
